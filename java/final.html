<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Final | Sorun Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/gitblog/assets/css/0.styles.5210e67a.css" as="style"><link rel="preload" href="/gitblog/assets/js/app.bb74211c.js" as="script"><link rel="preload" href="/gitblog/assets/js/2.78322325.js" as="script"><link rel="preload" href="/gitblog/assets/js/17.d9b52360.js" as="script"><link rel="prefetch" href="/gitblog/assets/js/10.df7eed06.js"><link rel="prefetch" href="/gitblog/assets/js/11.6d5d31ce.js"><link rel="prefetch" href="/gitblog/assets/js/12.c48dc15f.js"><link rel="prefetch" href="/gitblog/assets/js/13.38efcbdf.js"><link rel="prefetch" href="/gitblog/assets/js/14.9ac6d5ab.js"><link rel="prefetch" href="/gitblog/assets/js/15.ade29f8c.js"><link rel="prefetch" href="/gitblog/assets/js/16.4b3f8f9d.js"><link rel="prefetch" href="/gitblog/assets/js/18.187f8f04.js"><link rel="prefetch" href="/gitblog/assets/js/19.7943e5ab.js"><link rel="prefetch" href="/gitblog/assets/js/3.60832a0f.js"><link rel="prefetch" href="/gitblog/assets/js/4.1ec4d5f4.js"><link rel="prefetch" href="/gitblog/assets/js/5.657d4fd9.js"><link rel="prefetch" href="/gitblog/assets/js/6.3d277fb6.js"><link rel="prefetch" href="/gitblog/assets/js/7.d0d25033.js"><link rel="prefetch" href="/gitblog/assets/js/8.22b417ae.js"><link rel="prefetch" href="/gitblog/assets/js/9.acb4051a.js">
    <link rel="stylesheet" href="/gitblog/assets/css/0.styles.5210e67a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/gitblog/" class="home-link router-link-active"><img src="https://img.zcool.cn/community/01a2485545680f0000019ae9da087c.jpg@1280w_1l_2o_100sh.jpg" alt="Sorun Blog" class="logo"> <span class="site-name can-hide">Sorun Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/gitblog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/gitblog/java/" class="nav-link router-link-active">
  Java
</a></div><div class="nav-item"><a href="/gitblog/algorithm/" class="nav-link">
  Algorithm
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Languages</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/gitblog/zh/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/gitblog/en/japanese/" class="nav-link">
  English
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/gitblog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/gitblog/java/" class="nav-link router-link-active">
  Java
</a></div><div class="nav-item"><a href="/gitblog/algorithm/" class="nav-link">
  Algorithm
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Languages</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/gitblog/zh/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/gitblog/en/japanese/" class="nav-link">
  English
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/gitblog/java/" aria-current="page" class="sidebar-link">Java</a></li><li><a href="/gitblog/java/final.html" aria-current="page" class="active sidebar-link">Final</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/gitblog/java/final.html#final关键字" class="sidebar-link">Final关键字</a></li><li class="sidebar-sub-header"><a href="/gitblog/java/final.html#final的内存语义" class="sidebar-link">final的内存语义</a></li><li class="sidebar-sub-header"><a href="/gitblog/java/final.html#final和static的区别" class="sidebar-link">final和static的区别</a></li><li class="sidebar-sub-header"><a href="/gitblog/java/final.html#为什么局部内部类和匿名内部类只能访问局部final变量" class="sidebar-link">为什么局部内部类和匿名内部类只能访问局部final变量？</a></li></ul></li><li><a href="/gitblog/java/one.html" class="sidebar-link">JAVA-ONE</a></li><li><a href="/gitblog/java/two.html" class="sidebar-link">JAVA-TWO</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="final"><a href="#final" class="header-anchor">#</a> Final</h1> <h2 id="final关键字"><a href="#final关键字" class="header-anchor">#</a> Final关键字</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>final作为java的关键字，它可以修饰类，方法，变量及参数。</p></div> <h3 id="类"><a href="#类" class="header-anchor">#</a> 类</h3> <p>当final修饰一个类时，表明其为最终类，它不能被<code>继承</code>，并且类中所有的<code>属性和方法都默认是final类型</code>，如String，Integer等包装类均为final类。</p> <h3 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h3> <p>被final修饰的方法不可被重写。它可以防止任何继承类修改方法的意义和实现，而且，使用final修饰方法的执行效率一般高于普通方法，这里不得不提一下Java的内联机制。</p> <blockquote><p>当我们调用方法时，实际上是将程序的执行转移到该方法所在的内存地址上，将该方法执行完后，再返回到执行该方法前的位置，这种转移操作要求在转移前保存当前的数据以及内存地址，在执行完后再恢复现场，继续按照转移前的地址执行，也就是通常所说的压栈和出栈（这段文字有点绕口，简单来说，比如A方法在执行到第10行的时候调用了B方法，JVM会先保存A方法当前数据和执行地址，然后跳转到B方法所在的内存地址执行B方法，执行完后，再返回A方法第十行继续执行），因此，函数调用有一定时间和空间方面的开销，对于函数体积不大，但是频繁调用的函数来说，这个开销就会放大。
因此，对于这种函数体积不大又频繁调用的的方法，我们可以通过内联函数来提升运行效率，当我们对一个方法使用final修饰时，这个方法就有可能成为内联函数（JVM会根据方法的执行效率决定是否内联）。
。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。
类中所有的private方法都隐式地指定为final。</p></blockquote> <p>看下面代码，解释函数内联前后的区别。</p> <p>内联前：</p> <div class="language-java line-numbers-mode"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token comment">//调用a的get方法</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>内联后：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class A {
    int value;
    public final int get(){
        return value;
    }
}

public class B {
    public void sum() {
        A a = new A(); 
        //此处将get方法展开为内联函数
        int x = a.value;
    }
}
`反对`

曾经有一种广为流传的说法是用final修饰方法可以让对这个方法的调用变快。这种说法在现代主流的优化JVM上都是不成立的（例如Oracle JDK / OpenJDK HotSpot VM、IBM J9 VM、Azul Systems Zing VM等）。


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="变量"><a href="#变量" class="header-anchor">#</a> 变量</h3> <p>使用final修饰的变量称为常量（大写字母表示），只能被赋值一次，且赋值之后无法改变，这里的变量又可以分为基本类型变量和引用类型变量，final修饰基本类型变量时，变量的值不可改变；修饰引用变量时，变量指向的对象地址不可改变。</p> <p>这里还涉及到了一个类似C语言的宏替换概念，由于final修饰的String变量不可更改，所以，当一个String变量被final修饰时，这个值在编译期就可以确定，所有将该变量直接替换为它对应的值，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public class test {
    public static void main(String[] args) {
        final String a = &quot;hello&quot;;
        String b = &quot;hello&quot;;
        final String c = &quot;world&quot;;
        String d = &quot;hello&quot; + &quot;world&quot;;
        String e = a + c;
        String f = b + c;
        String g = &quot;helloworld&quot;;
        System.out.println(g == d);//true
        System.out.println(g == e);//true
        System.out.println(g == f);//false
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在编译期，由于a和c的值已经确定并且不会再更改（效果同d），所以e的值能够在编译期就确定下来，直接指向了常量区的g，前两个均为true；再看下f，由于b值的不确定性，所以在编译期不能确定其值，只能在运行时确认，所以（g == f）为false。</p> <h3 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h3> <p>final修饰的参数有一个只读的属性，即可以读取该参数，但是无法更改参数的值，同修饰变量一样，当参数为基本类型时，该参数的值不可改变；当参数为引用类型时，参数的引用地址不可改变。</p> <hr> <h2 id="final的内存语义"><a href="#final的内存语义" class="header-anchor">#</a> final的内存语义</h2> <p>在《【并发编程】揭开volatile的神秘面纱》中，说到了volatile可以禁止指令重排序，final同样有这样的作用，对于final域，编译器和处理器要遵守两个重排序规则。</p> <p>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
意思是说，在对象引用为任意线程可见之前，对象的final域已经被正确初始化了（JVM禁止把final域的写重排序到构造函数之外，要保证该效果，还要确保final引用没有从构造函数溢出）。</p> <p>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。
意思是说，在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p> <p>对于内存语义这块，还需要结合代码去理解，参考《Java并发编程的艺术》一书3.6节。</p> <hr> <h2 id="final和static的区别"><a href="#final和static的区别" class="header-anchor">#</a> final和static的区别</h2> <p>static作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变。下面代码验证一下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public class FinalTest {
    public static void main(String[] args)  {
        AA aa1 = new AA();
        AA aa2 = new AA();
        System.out.println(aa1.i);
        System.out.println(aa1.j);
        System.out.println(aa2.i);
        System.out.println(aa2.j);
    }
}
//j值两个都一样，因为是static修饰的,全局只保留一份
//i值不一样，两个对象可能产生两个不同的值，
class AA {
    public final int i = (int) (Math.random()*100);
    public static int j = (int) (Math.random()*100);
}
//结果是 65、23、67、23
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><hr> <h2 id="为什么局部内部类和匿名内部类只能访问局部final变量"><a href="#为什么局部内部类和匿名内部类只能访问局部final变量" class="header-anchor">#</a> 为什么局部内部类和匿名内部类只能访问局部final变量？</h2> <p>为了解决这个问题，我们先要去使用代码去验证一下。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public class Test {
    public static void main(String[] args)  {     
    }   
    //局部final变量a,b
    public void test(final int b) {
        final int a = 10;
        //匿名内部类
        new Thread(){
            public void run() {
                System.out.println(a);
                System.out.println(b);
            };
        }.start();
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>上段代码中，如果把变量a和b前面的任一个final去掉，这段代码都编译不过。</p> <p>这段代码会被编译成两个class文件：Test.class和Test1.class。默认情况下，编译器会为匿名内部类和局部内部类起名为Outter1.class。</p> <p>原因是为什么呢？这是因为test()方法里面的参数a和b，在运行时，main线程快要结束，但是thread还没有开始。因此需要有一种机制，在使得运行thread线程时候能够调用a和b的值，怎办呢？java采用了一种复制的机制，</p> <p>也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/gitblog/java/" class="prev router-link-active">
        Java
      </a></span> <span class="next"><a href="/gitblog/java/one.html">
        JAVA-ONE
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/gitblog/assets/js/app.bb74211c.js" defer></script><script src="/gitblog/assets/js/2.78322325.js" defer></script><script src="/gitblog/assets/js/17.d9b52360.js" defer></script>
  </body>
</html>
