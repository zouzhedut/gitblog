(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{373:function(s,a,n){"use strict";n.r(a);var t=n(44),e=Object(t.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"final"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#final"}},[s._v("#")]),s._v(" Final")]),s._v(" "),n("h2",{attrs:{id:"final关键字"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#final关键字"}},[s._v("#")]),s._v(" Final关键字")]),s._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),n("p",[s._v("final作为java的关键字，它可以修饰类，方法，变量及参数。")])]),s._v(" "),n("h3",{attrs:{id:"类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[s._v("#")]),s._v(" 类")]),s._v(" "),n("p",[s._v("当final修饰一个类时，表明其为最终类，它不能被"),n("code",[s._v("继承")]),s._v("，并且类中所有的"),n("code",[s._v("属性和方法都默认是final类型")]),s._v("，如String，Integer等包装类均为final类。")]),s._v(" "),n("h3",{attrs:{id:"方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[s._v("#")]),s._v(" 方法")]),s._v(" "),n("p",[s._v("被final修饰的方法不可被重写。它可以防止任何继承类修改方法的意义和实现，而且，使用final修饰方法的执行效率一般高于普通方法，这里不得不提一下Java的内联机制。")]),s._v(" "),n("blockquote",[n("p",[s._v("当我们调用方法时，实际上是将程序的执行转移到该方法所在的内存地址上，将该方法执行完后，再返回到执行该方法前的位置，这种转移操作要求在转移前保存当前的数据以及内存地址，在执行完后再恢复现场，继续按照转移前的地址执行，也就是通常所说的压栈和出栈（这段文字有点绕口，简单来说，比如A方法在执行到第10行的时候调用了B方法，JVM会先保存A方法当前数据和执行地址，然后跳转到B方法所在的内存地址执行B方法，执行完后，再返回A方法第十行继续执行），因此，函数调用有一定时间和空间方面的开销，对于函数体积不大，但是频繁调用的函数来说，这个开销就会放大。\n因此，对于这种函数体积不大又频繁调用的的方法，我们可以通过内联函数来提升运行效率，当我们对一个方法使用final修饰时，这个方法就有可能成为内联函数（JVM会根据方法的执行效率决定是否内联）。\n。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。\n类中所有的private方法都隐式地指定为final。")])]),s._v(" "),n("p",[s._v("看下面代码，解释函数内联前后的区别。")]),s._v(" "),n("p",[s._v("内联前：")]),s._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("div",{staticClass:"highlight-lines"},[n("br"),n("br"),n("div",{staticClass:"highlighted"},[s._v(" ")]),n("br"),n("br"),n("br"),n("br"),n("br"),n("br"),n("br"),n("br"),n("br"),n("br"),n("br"),n("br")]),n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" value"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("get")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" value"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("B")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("sum")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),s._v(" a "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" \n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//调用a的get方法")]),s._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" x "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("get")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])]),n("p",[s._v("内联后：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class A {\n    int value;\n    public final int get(){\n        return value;\n    }\n}\n\npublic class B {\n    public void sum() {\n        A a = new A(); \n        //此处将get方法展开为内联函数\n        int x = a.value;\n    }\n}\n`反对`\n\n曾经有一种广为流传的说法是用final修饰方法可以让对这个方法的调用变快。这种说法在现代主流的优化JVM上都是不成立的（例如Oracle JDK / OpenJDK HotSpot VM、IBM J9 VM、Azul Systems Zing VM等）。\n\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br")])]),n("h3",{attrs:{id:"变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[s._v("#")]),s._v(" 变量")]),s._v(" "),n("p",[s._v("使用final修饰的变量称为常量（大写字母表示），只能被赋值一次，且赋值之后无法改变，这里的变量又可以分为基本类型变量和引用类型变量，final修饰基本类型变量时，变量的值不可改变；修饰引用变量时，变量指向的对象地址不可改变。")]),s._v(" "),n("p",[s._v("这里还涉及到了一个类似C语言的宏替换概念，由于final修饰的String变量不可更改，所以，当一个String变量被final修饰时，这个值在编译期就可以确定，所有将该变量直接替换为它对应的值，如下：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('public class test {\n    public static void main(String[] args) {\n        final String a = "hello";\n        String b = "hello";\n        final String c = "world";\n        String d = "hello" + "world";\n        String e = a + c;\n        String f = b + c;\n        String g = "helloworld";\n        System.out.println(g == d);//true\n        System.out.println(g == e);//true\n        System.out.println(g == f);//false\n    }\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])]),n("p",[s._v("在编译期，由于a和c的值已经确定并且不会再更改（效果同d），所以e的值能够在编译期就确定下来，直接指向了常量区的g，前两个均为true；再看下f，由于b值的不确定性，所以在编译期不能确定其值，只能在运行时确认，所以（g == f）为false。")]),s._v(" "),n("h3",{attrs:{id:"参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参数"}},[s._v("#")]),s._v(" 参数")]),s._v(" "),n("p",[s._v("final修饰的参数有一个只读的属性，即可以读取该参数，但是无法更改参数的值，同修饰变量一样，当参数为基本类型时，该参数的值不可改变；当参数为引用类型时，参数的引用地址不可改变。")]),s._v(" "),n("hr"),s._v(" "),n("h2",{attrs:{id:"final的内存语义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#final的内存语义"}},[s._v("#")]),s._v(" final的内存语义")]),s._v(" "),n("p",[s._v("在《【并发编程】揭开volatile的神秘面纱》中，说到了volatile可以禁止指令重排序，final同样有这样的作用，对于final域，编译器和处理器要遵守两个重排序规则。")]),s._v(" "),n("p",[s._v("在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。\n意思是说，在对象引用为任意线程可见之前，对象的final域已经被正确初始化了（JVM禁止把final域的写重排序到构造函数之外，要保证该效果，还要确保final引用没有从构造函数溢出）。")]),s._v(" "),n("p",[s._v("初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。\n意思是说，在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。")]),s._v(" "),n("p",[s._v("对于内存语义这块，还需要结合代码去理解，参考《Java并发编程的艺术》一书3.6节。")]),s._v(" "),n("hr"),s._v(" "),n("h2",{attrs:{id:"final和static的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#final和static的区别"}},[s._v("#")]),s._v(" final和static的区别")]),s._v(" "),n("p",[s._v("static作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变。下面代码验证一下")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public class FinalTest {\n    public static void main(String[] args)  {\n        AA aa1 = new AA();\n        AA aa2 = new AA();\n        System.out.println(aa1.i);\n        System.out.println(aa1.j);\n        System.out.println(aa2.i);\n        System.out.println(aa2.j);\n    }\n}\n//j值两个都一样，因为是static修饰的,全局只保留一份\n//i值不一样，两个对象可能产生两个不同的值，\nclass AA {\n    public final int i = (int) (Math.random()*100);\n    public static int j = (int) (Math.random()*100);\n}\n//结果是 65、23、67、23\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br")])]),n("hr"),s._v(" "),n("h2",{attrs:{id:"为什么局部内部类和匿名内部类只能访问局部final变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么局部内部类和匿名内部类只能访问局部final变量"}},[s._v("#")]),s._v(" 为什么局部内部类和匿名内部类只能访问局部final变量？")]),s._v(" "),n("p",[s._v("为了解决这个问题，我们先要去使用代码去验证一下。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public class Test {\n    public static void main(String[] args)  {     \n    }   \n    //局部final变量a,b\n    public void test(final int b) {\n        final int a = 10;\n        //匿名内部类\n        new Thread(){\n            public void run() {\n                System.out.println(a);\n                System.out.println(b);\n            };\n        }.start();\n    }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br")])]),n("p",[s._v("上段代码中，如果把变量a和b前面的任一个final去掉，这段代码都编译不过。")]),s._v(" "),n("p",[s._v("这段代码会被编译成两个class文件：Test.class和Test1.class。默认情况下，编译器会为匿名内部类和局部内部类起名为Outter1.class。")]),s._v(" "),n("p",[s._v("原因是为什么呢？这是因为test()方法里面的参数a和b，在运行时，main线程快要结束，但是thread还没有开始。因此需要有一种机制，在使得运行thread线程时候能够调用a和b的值，怎办呢？java采用了一种复制的机制，")]),s._v(" "),n("p",[s._v("也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。")])])}),[],!1,null,null,null);a.default=e.exports}}]);